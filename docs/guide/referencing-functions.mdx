---
title: "Integrate APIs"
description: "Call public or custom functions from anywhere"
---

## Running functions via API

Running any public functions via API can be done through the [Push](/reference-v2/api/create-new-job) endpoint.

    ```bash API
    curl -X POST \
      --url https://mango.sievedata.com/v2/push \
      -H 'X-API-Key: <your-api-key>' \
      -H 'Content-Type: application/json' \
      --data '{
        "function": "sieve/dubbing"
        "inputs": {
          "file": {"url": "https://storage.googleapis.com/sieve-prod-us-central1-public-file-upload-bucket/c27fa3e7-d590-4208-ab8e-57fe69e7a4b9/9acf16f7-be0e-4522-a933-13abcd2fd6e3-input-source_file.mp4"},
          "target_language": "spanish"
        }
      }'
    ```

## Running functions in Python

You may also reference & run functions in Python directly. This has a couple key benefits:

- Calling your function will return a Python object directly in-line rather than JSON
- Async job handling is handled by default. No need to poll for outputs or job status
- Calling a function from inside a Sieve function is faster and takes advantage of file caching. Contact us to learn more.

```python Python Client
import sieve

source_file = sieve.File(url="https://storage.googleapis.com/sieve-prod-us-central1-public-file-upload-bucket/c27fa3e7-d590-4208-ab8e-57fe69e7a4b9/9acf16f7-be0e-4522-a933-13abcd2fd6e3-input-source_file.mp4")
dubbing = sieve.function.get("sieve/dubbing")
target_language = "spanish"
output = dubbing.run(source_file, target_language)

for output_object in output:
print(output_object.path)
```

<Note>
  Function inputs and outputs vary from function to function. Please refer to
  respective function's [Usage
  Guide](https://www.sievedata.com/functions/sieve/autocrop/guide) for more
  information about integration.
</Note>

The Sieve Python client lets you run functions synchronously or asynchronously. Let’s take the [Dubbing API]("https://www.sievedata.com/functions/sieve/dubbing") for example.

You can also `push` to a queue of a function and wait for the request to complete asynchronously. This is especially beneficial if you’d like to send many requests at once. You can then get the outputs of these jobs by calling `.result()` which is blocking and waits for the result to be received. The `push` method returns a Python future, which can be used with other Python async utilities.

<CodeGroup>
```python Sync Calls
# Running Dubbing synchronously
dubbing = sieve.function.get("sieve/dubbing")
dubbing_job = dubbing.run(file, target_language="spa")
```

```python Async Calls
# Running Dubbing asynchronously
dubbing = sieve.function.get("sieve/dubbing")
dubbing_job = dubbing.push(file, target_language="spa")

# dubbing_job is a Python future, so you can use it in a non-blocking way
print(dubbing_job) # <Future at 0x7f8e3c3e3e50 state=running>
for output_object in dubbing_job.result():
    print(output_object.path) # Path of dubbed file
```

</CodeGroup>
